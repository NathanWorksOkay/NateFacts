<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Spin the Wheel - Select Text from JSON</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root { --size: 520px; --accent: #222; --bg: #f7f7f9; }
        html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#111;background:var(--bg)}
        .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:24px;gap:18px}
        .wheel-container{position:relative;width:var(--size);height:var(--size);display:flex;align-items:center;justify-content:center}
        canvas#wheel{width:100%;height:100%;border-radius:50%;box-shadow:0 6px 18px rgba(0,0,0,0.12);transform-origin:center center;will-change:transform}
        .pointer{position:absolute;top:6px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;border-bottom:22px solid var(--accent);filter:drop-shadow(0 2px 4px rgba(0,0,0,0.18))}
        .controls{display:flex;gap:12px;align-items:center}
        button{background:#0066ff;color:white;border:0;padding:10px 14px;border-radius:8px;font-weight:600;cursor:pointer;box-shadow:0 4px 10px rgba(0,102,255,0.14)}
        button[disabled]{opacity:.5;cursor:default}
        .result{max-width:720px;background:white;padding:14px 16px;border-radius:10px;box-shadow:0 6px 20px rgba(0,0,0,0.06);text-align:left}
        .title{font-weight:700;margin-bottom:6px}
        .small{font-size:13px;color:#555}
        .file{font-size:13px;color:#444}
        input[type=file]{display:none}
        .info{font-size:13px;color:#666}
    </style>
</head>
<body>
    <div class="wrap">
        <div class="wheel-container" aria-hidden="true">
            <div class="pointer" title="Result pointer"></div>
            <canvas id="wheel" width="520" height="520"></canvas>
        </div>

        <div class="controls">
            <label class="file">
                <input id="fileInput" type="file" accept="application/json">
                <button id="loadBtn" type="button">Load JSON file</button>
            </label>
            <button id="spinBtn" type="button">Spin</button>
            <button id="randomizeBtn" type="button">Random list</button>
        </div>

        <div class="result" id="result" aria-live="polite">
            <div class="title" id="resTitle">No selection yet</div>
           <!--  <div class="small" id="resText">Load entities.json or press "Random list" to use a sample set, then spin the wheel to pick one.</div>
        </div>

             <div class="info">Expected JSON format: an array of objects [{"title":"...","text":"..."}, ...]</div> -->

    </div>

    <script type="module">
    (async () => {
        // Load ./FactFiles/MathFacts.json using import assertion or fetch as a fallback.
        async function loadFactFile() {
            try {
                const mod = await import("./FactFiles/MathFacts.json", { assert: { type: "json" } });
                return mod.default;
            } catch (e) {
                try {
                    const res = await fetch('./FactFiles/MathFacts.json', { cache: 'no-store' });
                    if (!res.ok) throw new Error('Failed to fetch ./FactFiles/MathFacts.json');
                    return await res.json();
                } catch (err) {
                    console.warn('Could not load ./FactFiles/MathFacts.json', e, err);
                    return null;
                }
            }
        }

        // Add Wheel asset
        const canvas = document.getElementById('wheel');
        const ctx = canvas.getContext('2d');
        const spinBtn = document.getElementById('spinBtn');
        const loadBtn = document.getElementById('loadBtn');
        const fileInput = document.getElementById('fileInput');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const resTitle = document.getElementById('resTitle');
        const resText = document.getElementById('resText');

        let entities = [];
        let factData = null; // stores MathFacts.json content if loaded
        let currentRotation = 0;
        let isSpinning = false;

        const DPR = Math.max(1, window.devicePixelRatio || 1);
        const SIZE = 520;
        canvas.width = SIZE * DPR;
        canvas.height = SIZE * DPR;
        canvas.style.width = SIZE + 'px';
        canvas.style.height = SIZE + 'px';
        ctx.setTransform(DPR,0,0,DPR,0,0);

        function loadFromFile(file) {
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(reader.result);
                    if (!Array.isArray(data) || data.length === 0) throw new Error('JSON must be a non-empty array');
                    entities = data;
                    drawWheel();
                    setResult('Ready', 'Loaded ' + entities.length + ' items from file.');
                } catch (e) {
                    setResult('Invalid JSON', e.message);
                }
            };
            reader.readAsText(file);
        }

        async function tryFetchDefault() {
            try {
                const r = await fetch('entities.json', {cache:'no-store'});
                if (!r.ok) throw new Error('No entities.json found');
                const data = await r.json();
                if (!Array.isArray(data) || data.length === 0) throw new Error('entities.json must be a non-empty array');
                entities = data;
                drawWheel();
                setResult('Ready', 'Loaded entities.json (' + entities.length + ' items).');
                return true;
            } catch (e) {
                return false;
            }
        }

        function sampleEntities() {
            // If the MathFacts.json (factData) is available use a shuffled copy, else fallback.
            if (Array.isArray(factData) && factData.length > 0) {
                entities = factData.slice().sort(() => Math.random() - 0.5);
            } else {
                entities = Array.from({ length: 8 }, (_, i) => ({ title: 'Item ' + (i + 1), text: '' }));
            }
            drawWheel();
            setResult('Sample list loaded', 'Using a generated sample list with ' + entities.length + ' items.');
        }

        function setResult(title, text) {
            resTitle.textContent = title;
            resText.textContent = text;
        }

        function drawWheel() {
            const n = Math.max(1, entities.length);
            const cx = SIZE/2, cy = SIZE/2, r = SIZE/2 - 8;
            ctx.clearRect(0,0,SIZE,SIZE);
            ctx.save();
            ctx.translate(cx,cy);

            const sliceDeg = 360 / n;
            for (let i=0;i<n;i++){
                const start = (i * sliceDeg) * Math.PI/180;
                const end = ((i+1) * sliceDeg) * Math.PI/180;
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.arc(0,0,r,start,end,false);
                ctx.closePath();
                ctx.fillStyle = `hsl(${(i*(360/n))},70%,60%)`;
                ctx.fill();
                // slice border
                ctx.strokeStyle = 'rgba(255,255,255,0.9)';
                ctx.lineWidth = 1.5;
                ctx.stroke();

                // label wheel
                const mid = (start+end)/2;
                ctx.save();
                ctx.rotate(mid);
                ctx.translate(r * 0.6, 0);
                ctx.rotate(Math.PI/2); // keep text from flipping
                ctx.fillStyle = '#111';
                ctx.font = 'bold 14px system-ui,Segoe UI,Roboto';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const label = (entities[i] && entities[i].title) ? entities[i].title : ('Item ' + (i+1));
                wrapText(ctx, label, 100, -10, 18);
                ctx.restore();
            }

            // center circle
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.arc(0,0, r*0.18, 0, Math.PI*2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(0,0,0,0.06)';
            ctx.stroke();

            ctx.restore();
        }

        function wrapText(ctx, text, maxWidth, yOffset, lineHeight){
            // morph the label
            const words = text.split(' ');
            let line = '';
            let y = yOffset;
            for (let n = 0; n < words.length; n++) {
                const testLine = line + (line ? ' ' : '') + words[n];
                const metrics = ctx.measureText(testLine);
                if (metrics.width > maxWidth && line) {
                    ctx.fillText(line, 0, y);
                    line = words[n];
                    y += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, 0, y);
        }

        function spin() {
            if (isSpinning || entities.length === 0) return;
            isSpinning = true;
            spinBtn.disabled = true;
            loadBtn.disabled = true;
            randomizeBtn.disabled = true;

            const n = entities.length;
            const sliceDeg = 360 / n;
            const targetIndex = Math.floor(Math.random() * n);
            const spins = 6 + Math.floor(Math.random()*3); // 6-8 spinnys
            const center = (targetIndex * sliceDeg) + sliceDeg/2;
            let offset = (270 - center) % 360;
            if (offset < 0) offset += 360;
            const finalDeg = spins*360 + offset;

            // animate via CSS
            canvas.style.transition = 'transform 4.2s cubic-bezier(.12,.9,.22,1)';
            canvas.style.transform = `rotate(${currentRotation + finalDeg}deg)`;

            // after transition, set final position
            function onEnd() {
                canvas.removeEventListener('transitionend', onEnd);
                currentRotation = (currentRotation + finalDeg) % 360;
                // reset style
                canvas.style.transition = '';
                canvas.style.transform = `rotate(${currentRotation}deg)`;
                isSpinning = false;
                spinBtn.disabled = false;
                loadBtn.disabled = false;
                randomizeBtn.disabled = false;
                const selected = entities[targetIndex];
                setResult(selected.title || ('Item ' + (targetIndex+1)), selected.text || '');
            }

            canvas.addEventListener('transitionend', onEnd);
        }

        // UI access
        spinBtn.addEventListener('click', spin);
        randomizeBtn.addEventListener('click', sampleEntities);
        loadBtn.addEventListener('click', ()=>fileInput.click());
        fileInput.addEventListener('change', e => {
            const f = e.target.files && e.target.files[0];
            if (f) loadFromFile(f);
            fileInput.value = '';
        });

        // Initialization: load ./FactFiles/MathFacts.json first, then fallback to entities.json, then sample.
        (async function init(){
            const data = await loadFactFile();
            if (Array.isArray(data) && data.length > 0) {
                factData = data;
                entities = factData.slice();
                drawWheel();
                setResult('Ready', 'Loaded ./FactFiles/MathFacts.json (' + entities.length + ' items).');
                // also expose for debugging
                window.jsonData = factData;
                return;
            }

            // if MathFacts didn't load, try entities.json (test file)
            const ok = await tryFetchDefault();
            if (!ok) sampleEntities();
        })();

        // Window resize handling
        window.addEventListener('resize', () => {
        });

        // Debugging
        window._wheel = { drawWheel, spin, getEntities: ()=>entities };
    })();
    </script>
</body>
</html>